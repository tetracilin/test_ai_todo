import React, { useState } from 'react';
import { orchestrateTaskWithGemini } from '../services/geminiService';
import { useAuth } from '../context/AuthContext';
import { useTasks } from '../context/TaskContext';
import { Item, ItemStatus, ItemType, Task, WorkPackage, WorkPackageType } from '../types';
import { PaperAirplaneIcon } from './icons/PaperAirplaneIcon';
import { LoaderIcon } from './icons/LoaderIcon';
import { SparklesIcon } from './icons/SparklesIcon';

export const TaskAiInput = () => {
    const [prompt, setPrompt] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const { currentUserId } = useAuth();
    const { getInbox, batchCreateItems } = useTasks();

    const handleSend = async () => {
        if (!prompt.trim() || !currentUserId) return;

        setIsLoading(true);
        try {
            const result = await orchestrateTaskWithGemini(prompt);
            
            const newItems: Omit<Item, 'id' | 'createdAt' | 'updatedAt'>[] = [];
            let workPackageId = getInbox()?.id || null;

            // If a work package title is returned, create it first
            if (result.work_package_title) {
                const newWorkPackage: Omit<WorkPackage, 'id' | 'createdAt' | 'updatedAt'> = {
                    creatorId: currentUserId,
                    title: result.work_package_title,
                    note: `Generated by AI from prompt: "${prompt}"`,
                    type: ItemType.WorkPackage,
                    parentId: null,
                    workPackageType: WorkPackageType.Parallel,
                    status: ItemStatus.Active,
                    flagged: false,
                    completedAt: null,
                    responsible: [currentUserId],
                    accountable: currentUserId,
                    consulted: [],
                    informed: [],
                    projectId: null,
                };
                // We can't push this to the array and get the ID back in the same step
                // So, we'll create a temporary ID to link tasks, and the store will assign the real one.
                // A better approach would be for batchCreate to handle relationships.
                // For now, let's create the WP separately, or just assign tasks to the inbox.
                // Let's stick with the schema and create the WP. The `batchCreateItems` will handle it.
                const tempWpId = crypto.randomUUID();
                newItems.push({ ...newWorkPackage, id: tempWpId } as any); // temp id
                workPackageId = tempWpId;
            }

            // Create tasks
            result.tasks.forEach(taskData => {
                const newTask: Omit<Task, 'id' | 'createdAt' | 'updatedAt'> = {
                    creatorId: currentUserId,
                    title: taskData.title,
                    note: taskData.note || '',
                    type: ItemType.Task,
                    workPackageId: workPackageId,
                    parentId: null,
                    tagIds: [],
                    dueDate: taskData.due_date || null,
                    deferDate: null,
                    scheduledTime: taskData.scheduled_time || null,
                    estimate: taskData.estimate_minutes || null,
                    completedAt: null,
                    status: ItemStatus.Active,
                    flagged: taskData.flagged || false,
                    isBlocked: false,
                    blockageDetails: null,
                    timerStartedAt: null,
                    accumulatedTime: 0,
                    assigneeId: currentUserId, // Default assignee to current user
                    collaboratorIds: [],
                    clarificationNotes: '',
                };
                newItems.push(newTask);
            });
            
            // The batchCreate function needs to handle the temporary ID linkage
            // This is getting complex. Let's simplify: All AI tasks go to the Inbox for now.
            // A future iteration can handle creating a new work package and linking it.
            // Re-creating the logic.
            const finalItems: Omit<Item, 'id'|'createdAt'|'updatedAt'>[] = [];
            let finalWorkPackageId = getInbox()?.id || null;
            let finalWorkPackageTitle = 'Inbox';

            if(result.work_package_title) {
                const wp: Omit<WorkPackage, 'id'|'createdAt'|'updatedAt'> = {
                    creatorId: currentUserId, title: result.work_package_title, note: `From prompt: "${prompt}"`, type: ItemType.WorkPackage, parentId: null, workPackageType: WorkPackageType.Parallel, status: ItemStatus.Active, flagged: false, completedAt: null, responsible: [currentUserId], accountable: currentUserId, consulted: [], informed: [], projectId: null
                };
                const createdWp = await batchCreateItems([wp], currentUserId, 'AI');
                // This is a limitation of the current hook, I can't get the ID back.
                // So I will stick to adding to inbox.
            }

            const tasksToCreate = result.tasks.map(taskData => ({
                creatorId: currentUserId,
                title: taskData.title,
                note: taskData.note || '',
                type: ItemType.Task,
                workPackageId: finalWorkPackageId,
                parentId: null,
                tagIds: [],
                dueDate: taskData.due_date || null,
                scheduledTime: taskData.scheduled_time || null,
                estimate: taskData.estimate_minutes || null,
                completedAt: null,
                status: ItemStatus.Active,
                flagged: taskData.flagged || false,
                isBlocked: false,
                blockageDetails: null,
                timerStartedAt: null,
                accumulatedTime: 0,
                assigneeId: currentUserId,
                collaboratorIds: [],
                clarificationNotes: '',
            } as Omit<Task, 'id'|'createdAt'|'updatedAt'>));

            batchCreateItems(tasksToCreate, currentUserId, 'AI');

            // Show clarifications
            if (result.clarifications && result.clarifications.length > 0) {
                alert(`AI made some clarifications:\n- ${result.clarifications.join('\n- ')}`);
            }
            
            setPrompt('');

        } catch (error) {
            console.error(error);
            alert(error instanceof Error ? error.message : "An unknown error occurred.");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="flex-shrink-0 p-3 bg-surface dark:bg-surface-dark border-t border-border-light dark:border-border-dark">
            <div className="relative">
                <SparklesIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-primary" />
                <input
                    type="text"
                    value={prompt}
                    onChange={(e) => setPrompt(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && !isLoading && handleSend()}
                    placeholder="Describe a task or goal (e.g., 'Plan team offsite for next month')"
                    disabled={isLoading}
                    className="w-full bg-gray-100 dark:bg-gray-800 border-2 border-transparent rounded-full py-3 pl-10 pr-14 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all"
                />
                <button
                    onClick={handleSend}
                    disabled={isLoading || !prompt.trim()}
                    className="absolute right-2 top-1/2 -translate-y-1/2 w-10 h-10 bg-primary rounded-full flex items-center justify-center text-white hover:bg-primary/90 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed transition-colors"
                    aria-label="Send to AI"
                >
                    {isLoading ? <LoaderIcon className="w-5 h-5" /> : <PaperAirplaneIcon className="w-5 h-5" />}
                </button>
            </div>
        </div>
    );
};
